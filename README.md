CG_SHOP_2025_2

- Βελτιστοποίηση Μη Αμβλυγώνιας Τριγωνοποίησης Επίπεδων Γράφων Ευθύγραμμων Τμημάτων (Planar StraightLine Graphs) με τη χρήση της βιβλιοθήκης CGAL.

- ΠΡΟΣΟΧΗ! Πριν την εκτέλεση του προγράμματος διαβάστε τις γραμμές 104-109 και 117 -120
===============================================================================================================================================
1. Περιγραφή: 
Η μείωση των αμβλυγώνιων τριγώνων γίνεται με τις εξής συναρτήσεις: 
void insert_projection(Custom_CDT& custom_cdt, const Face_handle& face, Polygon& polygon, Point_2& in_projection, Segment_2& opposide_edge);
void insert_midpoint(Custom_CDT& custom_cdt, const Face_handle& face, Polygon& polygon, Point_2& in_midpoint, Segment_2& longest_edge);
bool insert_adjecent_steiner(Custom_CDT& custom_cdt, const Face_handle& face, const Polygon& polygon, Point_2& adjecent_steiner);
bool insert_circumcenter(Custom_CDT& circumcenter_cdt, const Face_handle& face, const Polygon& polygon, Point_2& circumcenter_steiner);
void insert_centroid(Custom_CDT& centroid_cdt, const Face_handle& face, const Polygon& polygon, Point_2& centroid_steiner);

Γενικώς οι υλοποιήσεις των παραπάνω συναρτήσεων έχουν την φιλοσοφία να προσομιάζουμε (simulate) μια εισαγωγή steiner point, έχοντας ένα αντίγραφο της βασικής τριγωνοποίσης (cdt).

Η συνάρτηση start_the_flips() διατρέχει όλες τις ακμές του cdt βρίσκοντας τα 2 faces που χωρίζονται από αυτή της ακμή και από αυτά τα 2 faces παίρνει τα 4 σημεία τους (Points) και ελέγχει αρχικά αν τα 4 σημεία σχηματίζουν κυρτό πολύγωνο μέσω της συνάρτησης can_flip() ή οποία καλεί την is_convex() για να ελέγει την κυρτότητα του πολυγώνου. Η συνάρτηση can_flip() στο τέλος θα μας επιστρέψει γενικά αν μας συμφέρει (λιγότερες αμβλείες) να κάνουμε flip μια ακμή και όχι αν απλά γίνεται flip η ακμή.

Η συνάρτηση insert_circumcenter() εισάγει circumcenter point σε μια τριγωνοποίηση αν το circumcenter point είναι εντός boundary και αν η ακμή απέναντι από την κορυφή που δημιουργείται αμβλεία, δεν είναι ακμή constraint αλλά και το τετράπλευρο που σχηματίζουν τα σημεία του face με το face που μπήκε το circumcenter point αν είναι κυρτό.

Η συνάρτηση insert_centroid() εισάγει στο κέντρο του αμβληγώνιου τριγώνου το steiner point.

Η συνάρτηση insert_projection() διατρέχει τα faces του cdt, όταν βρεί αμβλυγώνιο τρίγωνο, βρίσκει σε ποιο point του face συμβαίνει αυτό αλλά και την ακμή απέναντι από την αμβλεία γωνία, ώστε να καλέσει την συνάρτηση line.projection() για να πάρουμε το σημείο προβολής της αμβλείας γωνίας με την απέναντι ευθεία.

Η συνάρτηση insert_midpoint() εισάγει στο μέσο της απέναντι πλευράς του obtuse vertex ένα steienr point.

Η συνάρτηση insert_adjecent_steiner() παίρνει ένα obtuse face και με αυξητικό τρόπο βρίσκει όλα τα γειτονικά τρίγωνα που είναι αμβλυγώνια και έχουν ώς μέρος τους αυτό το obtuse face που δέχτηκε στο όρισμα της. Ελέγχει αν το πολύγωνο που σχηματίζουν όλα αυτά τα obtuse faces είναι
κυρτό και εισάγει steiner point στο μέσο του πολυγώνου αυτού.

Η συνάρτηση insert_adjecent_steiner_local_search() χρησιμοποιείται μόνο για την μέθοδο της local search. Είναι πιο "έξυπνη" από την κλασσική 
insert_adjecent_steiner() καθώς σε κάθε βήμα της που προσθέτει obtuse γείτονες, ελέγχει και το κατά πόσο μείωσε τις αμβλείες αν προσέθετε steiner point στο μέσο αυτών των obtuse γειτόνων και κρατάει αυτό το υποσύνολο obtuse faces ππου μείωσαν περισσότερο τις αμβλείες στο cdt.

Όλες οι μέθοδοι, επειδή χρησιμοποιούν insert_no_flip(), μετά την εισαγωγή του εκάστοτε steiner point, κάνουν flips σε όλο το cdt με την custom συνάρτηση start_the_flips().

- Μέθοδος Local Search: 
Η μέθοδος αυτή ελέγχει για κάθε obtuse τρίγωνο όλες τις (5) μεθόδους εισαγωγής steiner και επιλέγει αυτή που μείωσε περισσότερο τα αμβλυγώνια μετά την εισαγωγή του steiner.

- Μέθοδος Simulated Annealing: 
Η μέθοδος αυτή, για κάθε obtuse τρίγωνο διαλέγει με τυχαίο τρόπο μια μέθοδο steiner και κάθε φορά που βρίσκει καλύτερη τριγωνοποίηση, την αποθηκεύει σαν best_cdt. Η μέθοδος αυτή τρέχει για L loops ή όταν η θερμοκρασία πλησιάσει το 0.
Επίσης αν υπάρξει βελτίωση της τριγωνοποίησης, η μέθοδος αυτή ξανατρέχει για L loops ή μέχρι η θερμοκρασίας να πλησιάσει το 0.
1) Κάθε φορά έχουμε ένα αντίγραφο cdt (simulate_cdt) του best_cdt και του εισάγουμε steiner ώστε να δούμε βελτίωση στην μείωση των αμβλειών.
2) Στην περίπτωση που δεν μπορεί να επιλεγεί το circumcenter κάνουμε skip το συγκεκριμένο obtuse face.
3) Στην περίπτωση που δεν μπορεί να επιλεγεί το steiner για τα γειτονικά τρίγωνα, επιλέγεται η μέθοδος της προβολής (projection).
4) Την μέθοδο αυτή την αφήνουμε για 180 iterations στην αρχή χωρίς να πειράξουμε την θερμοκρασία με σκοπό να φτάσει σε τοπικό ελάχιστο.
'Υστερα αυξάνουμε την θερμοκρασία με σκοπό να φύγουμε απο το τοπικό ελάχιστο που πέσαμε, έτσι ώστε να αυξηθούν οι πιθανότητες να επιλέγονται κακά steiner. Το πρόγραμμα δέχεται περισσότερα από 1 κακά steiner μέχρι να δεί βελτίωση, η παράμετρος αυτή ονομάζεται batch size και ορίζεται από τον χρήστη στο input json file.
5) Εφόσον εισαχθούν ακριβώς batch size κακά steiner points, το simulate_cdt ξαναγίνεται best_cdt ώστε να αρχίσουμε νέο κύκλο εισαγωγής "κακών" steiner points, με σκοπό να δούμε βελτίωση στην μείωση των αμβλειών.
Αυτό το "restart" από simulated cdt σε best_cdt γίνεται είτε όταν έχουμε εισάγει batch_size steiners και δεν είχαμε βελτίωση, είτε αν αυτές οι εισαγωγές κακών steiner μας χάλασαν την τριγωνοποίηση (αντί να μας την βελτιώσει) κατά 3 ή και περισσότερες αμβλείες.
6) Επίσης με σκοπό το πρόγραμμα να επαναφέρει την simulate τριγωνοποίηση σε best_cdt τριγωνοποίηση επειδή η τριγωνοποίηση χειροτέρεψε κατά 3 ή περισσότερες αμβλείες, τότε ορίζουμε το ΔΕ = 0.000001 έτσι ώστε στον υπολογισμό της πιθανότητας (e^(-∆E / T)) που δέχεται τα κακά steiner, νε είναι ίση με 1 που σημαίνει ότι θα μπούμε στην περίπτωση που δεχόμαστε κακό steiner αλλά θα ελεγχθεί ότι η simulated τριγωνοποίηση χειροτέρεψε κατά πολύ (3 steiner) και θα την επαναφέρει στην best_cdt μορφή ώστε να ξεκινήσει νέο κύκλο εισαγωγής steiner.
7) Η θερμοκρασία δεν μειώνεται γραμικά, αλλά πολλαπλασιαστικά κατά Τ*0.99 έτσι ώστε να παραμένουμε περισσότερο χρόνο ψηλά στην "κοιλάδα" έτσι ώστε να μπορούμε να μεταφρθούμε σε γειτονικά ελάχιστα.
8) Τα α και β που επιλέχθηκαν είναι χαμηλά (α = 2.4 και β = 0.2) και αυτό διότι θέλουμε το ΔΕ της πιθανότητας επιλογής κακού steiner (e^(-∆E / T)) να είναι χαμηλό, έτσι ώστε όταν η θερμοκρασία είναι υψηλή, να υπάρχει μεγάλη πιθανότητα επιλογής κακού steiner ώστε να φύγουμε από τοπικά ελάχιστα.

- Μέθοδος Ant Colony:
Στην μέθοδο αυτή, δημιουργήθηκε μια κλάση ant, ώστε κάθε τέτοιο ant σε κάθε κύκλο να κρατάει όλες τις απαραίτητες πληροφορίες για το cdt που του εισήγαγε steiner point που κάποιες από αυτές είναι:
1) Set από faces τα οποία επηρέασε μετά από εισαγωγή steiner, ώστε μετά να συγκρίνει αυτό το set μετα τα set των άλλων μυρμηγκιών για ύπαρξη conflict.
2) Το cdt στο οποίο εισήγαγε steiner point.
3) Την μέθοδο steiner που χρησιμοποίησε.
4) Booleans μεταβλητές αν μείωσε τις αμβλείες και αν είναι μυρμήγκι που έπεσε σε conflict.

Μερική περιγραφή της μεθόδου Ant Colony:
Κάθε μυρμήγκι:
       Σε κάθε κύκλο "κουβαλάει" την καλυτερη τριγωνοποίηση (best_cdt) του προηγούμενου κύκλου.
       Βάζει ένα steiner point σε ένα τυχαίο obtuse face, με βάση τα heuristics που δώθηκαν.
Στο τέλος κάθε κύκλου κρατάμε σε ξεχωριστό vector (ant_reduce_obtuses_vector) τα μυρμήγκια που πέτυχαν μείωση αμβλυγωνίων με την εισαγωγή του steiner point.
Από αυτά, ελέγχουμε αν μεταξύ τους υπάρχει conflict και αν υπάρχει, κρατάμε το μυρμήγκι με την χαμηλότερη ενέργεια στο cdt που κουβαλάει και αυτά τα τελικά μυρμήγκια τα βάζουμε σε άλλον vector (ant_last_winners_vector).
Κάνουμε merge τις λύσεις των μυρμηγκιών του ant_last_winners_vector και ενημερώνουμε το νέο best_cdt.
Γίνεται ενημέρωση φερομόνης κτλπ.

===============================================================================================================================================

2. Οργάνωση Φακέλων: 
CG_SHOP_2025_2: 
/tests: 
Τα .json instances που δόθηκαν ώστε να ελέγξουμε τον κώδικά μας. 

/includes/utils: 
a. Custom_Constrained_Delaunay_triangulation_2.h  
b. functions.h : οι δηλώσεις των συναρτήσεων.
c. functions_task1.h : Οι ορισμοί των συναρτήσεων που υλοποιήσαμε στην 1η εργασία.
d. ant.h : Ο ορισμός της κλάσης των μυρμηγκιών που χρησιμοποιούνται εφόσον επιλεχθεί η μέθοδος Ant Colony.
e. libraries.h : Βιβλιοθήκες της CGAL, Standard c++ αλλά και custom ώστε να τις κάνουν include τα αρχεία που τις χρειάζονται.
    Περιέχει και enumeration της κάθε μεθόδου steiner που χρειαζόμαστε στην μέθοδο Ant Colony.
f. extra_graphics.h : γραφικά για την εκτύπωση του CDT με χρωματισμό των τριγώνων που είναι αμβλυγώνια, των κορυφών όπου υπάρχει     αμβλεία γωνία, αλλά και εμφάνιση των συντεταγμένων κάθε κορυφής.


- CMakeLists.txt: 
Το αρχείο που χρειάζεται για την εισαγωγή των κατάλληλων βιβλιοθηκών (CGAL, Boost, γραφικών) ώστε να παράγουμε το επιθυμητό εκτελέσιμο.
Δεν πρέπει να δημιουργηθεί νέο!

- functions.cpp : οι υλοποιήσεις των συναρτήσεων που δημιουργήσαμε ώστε να εκπονήσουμε την εργασία.

- ant.cpp : Η υλοποίηση της κλάσης των μυρμηγκιών που χρησιμοποιούνται εφόσον επιλεχθεί η μέθοδος Ant Colony.

- project.cpp: 
Το αρχείο μας με την main function που αντλεί δεδομένα από ένα .json αρχείο με δεδομένα για έναν γράφο πάνω στον οποίο δημιουργούμε την τριγωνοποίηση Delaunay, και την βελτιστοποιούμε μέσω προκαθορισμένων επιλογών από το αρχείο json ως εξής:
a. Εάν έχει ορισθεί ως false η παράμετρος delauney στο json αρχείο, εκτελείται ο κώδικας της 1ης εργασίας και παράγεται ένα CDT. 
Στην συνέχεια το CDT που είχε ως αποτέλεσμα η εκτέλεση της πρώτης εργασίας, γίνεται input σε μια από τις 3 μεθόδους (Local Search, Simulated Annealing, Ant Colony Optimization) που έχουν επιλεγεί
στο input.json file.
b. Αφού τρέξει η μια από τις 3 μεθόδους, παίρνουμε το αποτέλεσμα και τα στοιχεία της τριγωνοποίησης μπαίνουν στο utput.json file.

- functions_task1.cpp : Οι υλοποιήσεις των συναρτήσεων που υλοποιήσαμε στην 1η εργασία, οι οποίες δύναται να εκτελεστούν εφόσον δοθεί ως input "delauney: false".

- .git Ο φάκελος με τις πληροφορίες για push, commit etc στο Github Repository
===============================================================================================================================================
ΣΗΜΕΙΩΣΗ: 
Οι παρακάτω εντολές πρέπει να βρίσκονται στο αρχείο .bashrc: 
- export LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH 
- export DISPLAY=:0 export BOOST_ROOT= "το path που βρίσκεται ο φάκελος boost_1_80_0" 
- export CGAL_ROOT="το path που βρίσκεται ο φάκελος της βιβλιοθήκης CGAL-5.6.1" 
Χρησιμοποιήθηκε η έκδοση 1_80_0 της Boost στην υπολοποίησή μας.

3. Οδηγίες Μεταγλώττισης & Εκτέλεσης στο terminal: 
Step 1: /path/to/program 
Step 2: cmake -DCGAL_DIR=/usr/lib/CGAL 
Step 3: make 
Step 4: ./opt_triangulation -i tests/test_SA.json -o solution_output.json

- ΠΡΟΣΟΧΗ! Δεν πρέπει να τρέξει η εντολή cgal_create_CMakeLists -s, το CMakeLists.txt στον υπάρχον φάκελο είναι το κατάλληλο και περιέχει τα κατάλληλα includes βιβλιοθηκών για το υπάρχον πρόγραμμα.

- ΠΡΟΣΟΧΗ! Τα input json files για την μέθοδο Simulated Annealing περιέχουν μια επιπλέον παράμετρο, το batch size το οποίο ο χρήστης δηλώνει
τον αριθμό των "κακών" steiner points που δέχονται στην τριγωνοποίηση τους, μέχρι να δούμε βελτίωση στην τριγωνοποίηση.
===============================================================================================================================================

4. Το πρόγραμμα τρέχει με μια εντολή στο terminal τύπου ./opt_triangulation –i /path/to/input.json –o /path/to/output.json όπως ακριβώς ζητήθηκε στην εκφώνηση της εργασίας. Τα input json files περιέχουν όλες τις πληροφορίες για να τρέξει το πρόγραμμα.
Στον φάκελο tests υπάρχουν test cases που μπορείτε να δώσετε στο terminal.
==============================================================================================================================================
5. Στοιχεία Φοιτητών: 
ΠΑΠΑΔΗΜΟΠΟΥΛΟΣ ΜΙΧΑΗΛ-ΑΓΓΕΛΟΣ sdi2000163
ΑΝΑΣΤΑΣΟΠΟΥΛΟΣ ΑΝΔΡΕΑΣ sdi1900009
===============================================================================================================================================
6) 
- Η επιλογή των τιμών α και β στο Simulated Annealing είναι 2.4 και 0.2 αντίστοιχα, έτσι ώστε το ΔΕ να είναι χαμηλό ώστε να έχουμε περισσότερες πιθανότητες να διαλέξουμε κακά steiner την ώρα που έχουμε πέσει σε τοπικό ελάχιστο και θέλουμε να φύγουμε από αυτό για να οδηγηθούμε σε καλύτερο τοπικό ελάχιστο ή και ελάχιστο.
Η επιλογή του L στο SA είναι στα 1450 loops γιατί αυξομειώνουμε την θερμκρασία μέχρι εκείνη την στιγμή, με σκοπό να φύγουμε από τοπικό ελάχιστο.

- Η επιλογή του L = 40 στο ant colony είναι γιατί από εκεί και πέρα δεν βρήκαμε καμία βελτίωση σε κανένα test.
Επίσης η επιλογή για n/2 ants, έχει σκοπό να μπορέσουν σε έναν κύκλο πολλά μυρμήγκια να διαλέξουν και το ίδιο obtuse face αλλά με διαφορετική μέθοδο, με σκοπό να αυξήσουμε (αν όχι να εξαντλήσουμε) τους συνδυασμούς μεθόδων με βάση το κάθε obtuse face, ώστε να φτάσουμε σε ελάχιστο για την συγκεκριμένη μέθοδο.
Όσο για το λ το το ορίσαμε χαμηλά στο 0.2 και το ψ = 2.0, γιατί θέλουμε τα μυρμήγκια να θυμούνται την απόδοση της κάθε μεθόδου για περισσότερο χρόνο, βλέποντας έτσι και σταθερά βέλτιστη λύση στο πρόγραμμά μας σε σχέση με μεγαλύτερες τιμές.

- Η επιλογή L = 50 στην μέθοδο είναι τυπική, καθώς σταματάει αν μετά από έναν κύκλο από 50 loops δεν υπήρχε βελτίωση στην τριγωνοποίηση ή αν μηδενιστουν οι αμβλείες.
===============================================================================================================================================